// =============================================================================
// MATCHER ENGINE v6 — Chrome Extension Module
// =============================================================================
// Pure matching logic. No DOM, no Chrome APIs. Just text in, matches out.
//
// Changes from v5:
//   - Case-sensitive support via CS: prefix (e.g., "CS:HP" or "CS://ELF")
//   - Exported as global (window.MatcherEngine) for use by content script
//   - enabled flag on categories respected at compile time
//
// WORD ENTRY SYNTAX:
//   walmart           → substring, case-insensitive
//   //walmart         → exact (whole-word), case-insensitive
//   CS:walmart        → substring, case-SENSITIVE
//   CS://walmart      → exact, case-SENSITIVE
//   " elf "           → boundary spaces (require whitespace/punctuation around)
//   amazon*           → wildcard (end)
//   *etailer          → wildcard (start)
//   sh*t              → wildcard (middle, stays in-token)
//   took * days       → wildcard (middle with spaces, spans words)
// =============================================================================
 
(function() {
  "use strict";
 
  // ---------------------------------------------------------------------------
  // STEP 1: Parse a raw word entry into a structured object.
  // ---------------------------------------------------------------------------
  function parseWordEntry(rawEntry) {
    let text = rawEntry;
    let exact = false;
    let caseSensitive = false;
 
    // Check for CS: prefix (case-sensitive flag)
    if (text.startsWith("CS:")) {
      caseSensitive = true;
      text = text.slice(3);
    }
 
    // Check for // prefix (exact flag)
    if (text.startsWith("//")) {
      exact = true;
      text = text.slice(2);
    }
 
    // Detect boundary markers BEFORE stripping whitespace
    const boundaryBefore = /^[\s\n\r\t]/.test(text);
    const boundaryAfter  = /[\s\n\r\t]$/.test(text);
 
    // Strip all leading/trailing whitespace
    text = text.trim();
 
    if (text.length === 0) return null;
 
    // Only lowercase if case-insensitive
    if (!caseSensitive) {
      text = text.toLowerCase();
    }
 
    return {
      pattern: text,
      exact: exact,
      caseSensitive: caseSensitive,
      boundaryBefore: exact ? true : boundaryBefore,
      boundaryAfter:  exact ? true : boundaryAfter,
    };
  }
 
 
  // ---------------------------------------------------------------------------
  // STEP 2: Convert a glob pattern into a regex fragment string.
  // ---------------------------------------------------------------------------
  function globToRegexFragment(pattern) {
    let result = "";
    const chars = [...pattern];
    const hasLiteralSpace = pattern.includes(" ");
 
    for (let i = 0; i < chars.length; i++) {
      const ch = chars[i];
      const isFirst = (i === 0);
      const isLast  = (i === chars.length - 1);
 
      if (ch === "*") {
        if (isFirst || isLast) {
          result += "[^\\s\\p{P}]*";
        } else {
          result += hasLiteralSpace ? "[\\s\\S]*?" : "[^\\s]*?";
        }
      } else if (ch === "?") {
        result += hasLiteralSpace ? "[\\s\\S]" : "[^\\s]";
      } else {
        result += ch.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
    }
    return result;
  }
 
 
  // ---------------------------------------------------------------------------
  // STEP 3: Wrap a glob fragment with boundary assertions if needed.
  // ---------------------------------------------------------------------------
  function compileWordToRegexFragment(parsed) {
    let fragment = "";
 
    if (parsed.boundaryBefore) {
      fragment += "(?:^|(?<=[\\s\\p{P}]))";
    }
 
    fragment += globToRegexFragment(parsed.pattern);
 
    if (parsed.boundaryAfter) {
      fragment += "(?=$|[\\s\\p{P}])";
    }
 
    return fragment;
  }
 
 
  // ---------------------------------------------------------------------------
  // STEP 4: Compile one category into RegExp(s).
  // Words are split into case-sensitive and case-insensitive groups,
  // each getting their own regex, so flags can differ.
  // ---------------------------------------------------------------------------
  function compileCategory(category) {
    const groups = { sensitive: [], insensitive: [] };
 
    for (const rawWord of category.words) {
      const parsed = parseWordEntry(rawWord);
      if (!parsed) continue;
 
      const fragment = compileWordToRegexFragment(parsed);
      const bucket = parsed.caseSensitive ? "sensitive" : "insensitive";
      groups[bucket].push({ fragment, parsed });
    }
 
    const regexes = [];
 
    for (const [key, items] of Object.entries(groups)) {
      if (items.length === 0) continue;
      // Longer patterns first for longest-match preference
      items.sort((a, b) => b.parsed.pattern.length - a.parsed.pattern.length);
      const combined = items.map(f => f.fragment).join("|");
      const flags = key === "sensitive" ? "gu" : "giu";
      try {
        regexes.push(new RegExp(combined, flags));
      } catch (e) {
        console.error(`Failed to compile regex for "${category.name}" (${key}):`, e.message);
      }
    }
 
    if (regexes.length === 0) return null;
 
    return {
      id:      category.id,
      name:    category.name,
      color:   category.color,
      fColor:  category.fColor,
      regexes: regexes,
    };
  }
 
 
  // ---------------------------------------------------------------------------
  // STEP 5: Compile everything — categories + ignore list.
  // ---------------------------------------------------------------------------
  function compileAll(config) {
    let ignoreCompiled = null;
    if (config.ignoreList && config.ignoreList.length > 0) {
      ignoreCompiled = compileCategory({
        id: "__ignore__",
        name: "Ignore List",
        color: null,
        fColor: null,
        words: config.ignoreList,
      });
    }
 
    const compiledCategories = [];
    for (const cat of config.categories) {
      if (cat.enabled === false) continue;
      const compiled = compileCategory(cat);
      if (compiled) compiledCategories.push(compiled);
    }
 
    return { ignoreCompiled, compiledCategories };
  }
 
 
  // ---------------------------------------------------------------------------
  // STEP 6: Run matching on a piece of text.
  // ---------------------------------------------------------------------------
  function findMatches(text, compiled) {
    const { ignoreCompiled, compiledCategories } = compiled;
 
    // --- Collect Ignore List match ranges ---
    const ignoreRanges = [];
    if (ignoreCompiled) {
      for (const regex of ignoreCompiled.regexes) {
        regex.lastIndex = 0;
        let m;
        while ((m = regex.exec(text)) !== null) {
          if (m[0].length === 0) { regex.lastIndex++; continue; }
          ignoreRanges.push({ start: m.index, end: m.index + m[0].length });
        }
      }
    }
 
    // --- Collect all category matches ---
    const allMatches = [];
    for (let i = 0; i < compiledCategories.length; i++) {
      const cat = compiledCategories[i];
      for (const regex of cat.regexes) {
        regex.lastIndex = 0;
        let m;
        while ((m = regex.exec(text)) !== null) {
          if (m[0].length === 0) { regex.lastIndex++; continue; }
          allMatches.push({
            start:    m.index,
            end:      m.index + m[0].length,
            name:     cat.name,
            color:    cat.color,
            fColor:   cat.fColor,
            priority: i,
          });
        }
      }
    }
 
    // --- Remove matches that overlap with any Ignore range ---
    let filtered = allMatches;
    if (ignoreRanges.length > 0) {
      filtered = allMatches.filter(match => {
        return !ignoreRanges.some(ig => match.start < ig.end && match.end > ig.start);
      });
    }
 
    // --- Resolve priority: sort by position, then priority ---
    filtered.sort((a, b) => {
      if (a.start !== b.start) return a.start - b.start;
      return a.priority - b.priority;
    });
 
    // --- Greedy sweep: keep only non-overlapping matches ---
    const final = [];
    let lastEnd = -1;
    for (const match of filtered) {
      if (match.start >= lastEnd) {
        final.push(match);
        lastEnd = match.end;
      }
    }
 
    return final.map(m => ({
      start:        m.start,
      end:          m.end,
      categoryName: m.name,
      color:        m.color,
      fColor:       m.fColor,
    }));
  }
 
 
  // ---------------------------------------------------------------------------
  // Export
  // ---------------------------------------------------------------------------
  const MatcherEngine = {
    parseWordEntry,
    compileAll,
    findMatches,
  };
 
  if (typeof module !== "undefined" && module.exports) {
    module.exports = MatcherEngine;
  } else if (typeof window !== "undefined") {
    window.MatcherEngine = MatcherEngine;
  }
})();
