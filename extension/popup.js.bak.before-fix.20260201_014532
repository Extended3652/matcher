// =============================================================================
// CMS Highlighter â€” Popup Script
// =============================================================================
// Controls:
//   - Master on/off toggle
//   - Per-category toggle + color picker (via left accent)
//   - Drag-to-reorder categories (priority)
//   - Inline per-category dictionary editor (search/add/remove)
//   - Global ignore quick-add (top)
//   - Refresh button
//   - Link to options page
// =============================================================================

(function() {
  "use strict";

  const masterToggle       = document.getElementById("masterToggle");
  const statsEl            = document.getElementById("stats");
  const catListEl          = document.getElementById("catList");
  const btnRefresh         = document.getElementById("btnRefresh");
  const btnOptions         = document.getElementById("btnOptions");

  const ignoreQuickInput   = document.getElementById("ignoreQuickInput");
  const ignoreQuickAddBtn  = document.getElementById("ignoreQuickAddBtn");
  const ignoreQuickExact   = document.getElementById("ignoreQuickExact");
  const ignoreQuickCS      = document.getElementById("ignoreQuickCS");

  let currentDict = null;
  let openEditorIndex = null;

  // ---------------------------------------------------------------------------
  // Small parsing helpers (mirror matcher-core.js prefix semantics)
  // ---------------------------------------------------------------------------
  function parseEntry(raw) {
    let text = String(raw || "");
    let exact = false;
    let cs = false;

    if (text.startsWith("CS:")) {
      cs = true;
      text = text.slice(3);
    }
    if (text.startsWith("//")) {
      exact = true;
      text = text.slice(2);
    }

    text = text.trim();
    return { raw: String(raw || ""), text, exact, cs };
  }

  function buildRaw(text, exact, cs) {
    let out = String(text || "").trim();
    if (!out) return "";
    if (exact) out = "//" + out;
    if (cs) out = "CS:" + out;
    return out;
  }

  function normalizeTrim(s) {
    return String(s || "").trim();
  }

  // ---------------------------------------------------------------------------
  // Load state from storage
  // ---------------------------------------------------------------------------
  function loadState() {
    chrome.storage.local.get(["dictionary", "enabled"], (result) => {
      const enabled = result.enabled !== false;
      masterToggle.checked = enabled;

      currentDict = result.dictionary || { ignoreList: [], categories: [] };
      if (!currentDict.ignoreList) currentDict.ignoreList = [];
      if (!currentDict.categories) currentDict.categories = [];

      renderCategories();
      updateStats();
    });
  }

  // ---------------------------------------------------------------------------
  // Save dictionary to storage (and refresh current tab)
  // ---------------------------------------------------------------------------
  function saveDictionaryAndRefresh() {
    chrome.storage.local.set({ dictionary: currentDict }, () => {
      // Content script also listens to storage changes, but we want immediate feel.
      refreshActiveTab();
      updateStats();
    });
  }

  function refreshActiveTab() {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]) {
        chrome.tabs.sendMessage(tabs[0].id, { action: "refresh" }).catch(() => {});
      }
    });
  }

  // ---------------------------------------------------------------------------
  // Global Ignore quick-add
  // ---------------------------------------------------------------------------
  function addToIgnoreFromQuick() {
    if (!currentDict) return;

    const base = normalizeTrim(ignoreQuickInput.value);
    if (!base) return;

    const raw = buildRaw(base, !!ignoreQuickExact.checked, !!ignoreQuickCS.checked);
    if (!raw) return;

    if (!currentDict.ignoreList) currentDict.ignoreList = [];

    if (currentDict.ignoreList.includes(raw)) {
      // brief feedback in button
      ignoreQuickAddBtn.textContent = "Exists";
      setTimeout(() => { ignoreQuickAddBtn.textContent = "Add"; }, 700);
      return;
    }

    currentDict.ignoreList.push(raw);
    ignoreQuickInput.value = "";
    saveDictionaryAndRefresh();

    ignoreQuickAddBtn.textContent = "Added";
    setTimeout(() => { ignoreQuickAddBtn.textContent = "Add"; }, 700);
  }

  ignoreQuickAddBtn.addEventListener("click", (e) => {
    e.preventDefault();
    addToIgnoreFromQuick();
  });

  ignoreQuickInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      addToIgnoreFromQuick();
    }
  });

  // ---------------------------------------------------------------------------
  // Render category list (+ inline editors)
  // ---------------------------------------------------------------------------
  function renderCategories() {
    catListEl.innerHTML = "";
    if (!currentDict || !currentDict.categories) return;

    currentDict.categories.forEach((cat, index) => {
      if (!cat.words) cat.words = [];

      // --- Row ---
      const item = document.createElement("div");
      item.className = "cat-item";
      item.draggable = true;
      item.dataset.index = index;

      // Left accent strip (click to change category BG color)
      const accentWrap = document.createElement("span");
      accentWrap.style.position = "relative";

      const accent = document.createElement("span");
      accent.className = "cat-accent";
      accent.style.backgroundColor = cat.color || "#FFFF00";

      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.className = "cat-color-input";
      colorInput.value = cat.color || "#FFFF00";

      colorInput.addEventListener("input", () => {
        accent.style.backgroundColor = colorInput.value;
        cat.color = colorInput.value;
        saveDictionaryAndRefresh();
      });

      // Prevent drag start when clicking accent
      accent.addEventListener("mousedown", (e) => e.stopPropagation());
      accent.addEventListener("click", (e) => {
        e.stopPropagation();
        colorInput.click();
      });

      accentWrap.appendChild(accent);
      accentWrap.appendChild(colorInput);
      item.appendChild(accentWrap);

      // Drag grip
      const grip = document.createElement("span");
      grip.className = "cat-grip";
      grip.textContent = "\u2630";
      item.appendChild(grip);

      // Name (do NOT apply fColor here, fixes the black text issue)
      const name = document.createElement("span");
      name.className = "cat-name";
      name.textContent = cat.name;
      name.title = cat.name;
      item.appendChild(name);

      // Word count
      const count = document.createElement("span");
      count.className = "cat-count";
      count.textContent = `${cat.words ? cat.words.length : 0}`;
      item.appendChild(count);

      // Edit button
      const editBtn = document.createElement("button");
      editBtn.className = "cat-edit-btn";
      editBtn.type = "button";
      editBtn.textContent = (openEditorIndex === index) ? "Close" : "Edit";
      editBtn.addEventListener("mousedown", (e) => e.stopPropagation());
      editBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        openEditorIndex = (openEditorIndex === index) ? null : index;
        renderCategories();
      });
      item.appendChild(editBtn);

      // Toggle
      const toggleLabel = document.createElement("label");
      toggleLabel.className = "toggle-switch cat-toggle";
      toggleLabel.addEventListener("mousedown", (e) => e.stopPropagation());
      toggleLabel.addEventListener("click", (e) => e.stopPropagation());

      const toggleInput = document.createElement("input");
      toggleInput.type = "checkbox";
      toggleInput.checked = cat.enabled !== false;
      toggleInput.addEventListener("change", () => {
        cat.enabled = toggleInput.checked;
        saveDictionaryAndRefresh();
      });

      const toggleSlider = document.createElement("span");
      toggleSlider.className = "toggle-slider";

      toggleLabel.appendChild(toggleInput);
      toggleLabel.appendChild(toggleSlider);
      item.appendChild(toggleLabel);

      // Drag events
      item.addEventListener("dragstart", onDragStart);
      item.addEventListener("dragover", onDragOver);
      item.addEventListener("dragleave", onDragLeave);
      item.addEventListener("drop", onDrop);
      item.addEventListener("dragend", onDragEnd);

      catListEl.appendChild(item);

      // --- Inline editor panel ---
      const editor = document.createElement("div");
      editor.className = "cat-editor" + (openEditorIndex === index ? " open" : "");
      editor.dataset.index = index;

      if (openEditorIndex === index) {
        // Search row
        const searchRow = document.createElement("div");
        searchRow.className = "row";

        const searchInput = document.createElement("input");
        searchInput.type = "text";
        searchInput.placeholder = "Search within this category";
        searchInput.value = cat.__popupSearch || "";

        searchInput.addEventListener("input", () => {
          cat.__popupSearch = searchInput.value;
          renderCategories();
        });

        searchRow.appendChild(searchInput);
        editor.appendChild(searchRow);

        // Add row
        const addRow = document.createElement("div");
        addRow.className = "row";

        const addInput = document.createElement("input");
        addInput.type = "text";
        addInput.placeholder = "Add a word/pattern and press Enter";

        const addBtn = document.createElement("button");
        addBtn.type = "button";
        addBtn.textContent = "Add";

        const flagsWrap = document.createElement("div");
        flagsWrap.className = "flags";

        const exactLabel = document.createElement("label");
        const exactCb = document.createElement("input");
        exactCb.type = "checkbox";
        exactLabel.appendChild(exactCb);
        exactLabel.appendChild(document.createTextNode(" Exact"));

        const csLabel = document.createElement("label");
        const csCb = document.createElement("input");
        csCb.type = "checkbox";
        csLabel.appendChild(csCb);
        csLabel.appendChild(document.createTextNode(" CS"));

        flagsWrap.appendChild(exactLabel);
        flagsWrap.appendChild(csLabel);

        function doAdd() {
          const base = normalizeTrim(addInput.value);
          if (!base) return;

          const raw = buildRaw(base, !!exactCb.checked, !!csCb.checked);
          if (!raw) return;

          if (cat.words.includes(raw)) {
            addBtn.textContent = "Exists";
            setTimeout(() => { addBtn.textContent = "Add"; }, 700);
            return;
          }

          cat.words.push(raw);
          count.textContent = `${cat.words.length}`;
          addInput.value = "";
          saveDictionaryAndRefresh();

          addBtn.textContent = "Added";
          setTimeout(() => { addBtn.textContent = "Add"; }, 700);
        }

        addBtn.addEventListener("click", (e) => {
          e.preventDefault();
          doAdd();
        });

        addInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            doAdd();
          }
        });

        addRow.appendChild(addInput);
        addRow.appendChild(addBtn);
        editor.appendChild(addRow);
        editor.appendChild(flagsWrap);

        // Word list (filtered)
        const list = document.createElement("div");
        list.className = "word-list";

        const q = normalizeTrim(cat.__popupSearch || "").toLowerCase();
        const allWords = Array.isArray(cat.words) ? cat.words.slice() : [];

        let filtered = allWords;
        if (q) {
          filtered = allWords.filter(w => String(w).toLowerCase().includes(q));
        }

        // Keep popup snappy with huge lists
        const LIMIT = 250;
        const display = filtered.slice(0, LIMIT);

        display.forEach((rawWord, wordIndexInDisplay) => {
          const parsed = parseEntry(rawWord);

          const row = document.createElement("div");
          row.className = "word-row";

          const text = document.createElement("div");
          text.className = "word-text";
          text.title = parsed.raw;
          text.textContent = parsed.text.length ? parsed.text : parsed.raw;
          row.appendChild(text);

          if (parsed.exact) {
            const pill = document.createElement("span");
            pill.className = "pill";
            pill.textContent = "Exact";
            row.appendChild(pill);
          }

          if (parsed.cs) {
            const pill = document.createElement("span");
            pill.className = "pill";
            pill.textContent = "CS";
            row.appendChild(pill);
          }

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "word-remove";
          removeBtn.textContent = "Remove";

          removeBtn.addEventListener("click", (e) => {
            e.preventDefault();

            // Remove by raw value (safer than index due to filters)
            const idx = cat.words.indexOf(parsed.raw);
            if (idx >= 0) {
              cat.words.splice(idx, 1);
              count.textContent = `${cat.words.length}`;
              saveDictionaryAndRefresh();
              renderCategories();
            }
          });

          row.appendChild(removeBtn);
          list.appendChild(row);
        });

        if (filtered.length > LIMIT) {
          const moreRow = document.createElement("div");
          moreRow.className = "word-row";
          const t = document.createElement("div");
          t.className = "word-text";
          t.style.color = "#888";
          t.textContent = `Showing ${LIMIT} of ${filtered.length}. Use search to narrow.`;
          moreRow.appendChild(t);
          list.appendChild(moreRow);
        }

        editor.appendChild(list);
      }

      catListEl.appendChild(editor);
    });
  }

  // ---------------------------------------------------------------------------
  // Drag and drop for reordering (priority)
  // ---------------------------------------------------------------------------
  let dragIndex = null;

  function onDragStart(e) {
    dragIndex = parseInt(e.currentTarget.dataset.index, 10);
    e.currentTarget.classList.add("dragging");
    e.dataTransfer.effectAllowed = "move";
  }

  function onDragOver(e) {
    e.preventDefault();
    e.currentTarget.classList.add("drag-over");
  }

  function onDragLeave(e) {
    e.currentTarget.classList.remove("drag-over");
  }

  function onDrop(e) {
    e.preventDefault();
    e.currentTarget.classList.remove("drag-over");

    const dropIndex = parseInt(e.currentTarget.dataset.index, 10);
    if (dragIndex === null || dragIndex === dropIndex) return;

    const cats = currentDict.categories;
    const moved = cats.splice(dragIndex, 1)[0];
    cats.splice(dropIndex, 0, moved);

    // Keep editor with the same category row after reorder:
    if (openEditorIndex !== null) {
      if (openEditorIndex === dragIndex) {
        openEditorIndex = dropIndex;
      } else if (dragIndex < openEditorIndex && dropIndex >= openEditorIndex) {
        openEditorIndex -= 1;
      } else if (dragIndex > openEditorIndex && dropIndex <= openEditorIndex) {
        openEditorIndex += 1;
      }
    }

    saveDictionaryAndRefresh();
    renderCategories();
  }

  function onDragEnd(e) {
    e.currentTarget.classList.remove("dragging");
    dragIndex = null;
    document.querySelectorAll(".drag-over").forEach(el => el.classList.remove("drag-over"));
  }

  // ---------------------------------------------------------------------------
  // Master toggle
  // ---------------------------------------------------------------------------
  masterToggle.addEventListener("change", () => {
    const enabled = masterToggle.checked;
    chrome.storage.local.set({ enabled: enabled });

    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]) {
        chrome.tabs.sendMessage(tabs[0].id, {
          action: "toggle",
          enabled: enabled,
        }).catch(() => {});
      }
    });
  });

  // ---------------------------------------------------------------------------
  // Stats
  // ---------------------------------------------------------------------------
  function updateStats() {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (!tabs[0]) {
        statsEl.textContent = "No active tab";
        return;
      }

      chrome.tabs.sendMessage(tabs[0].id, { action: "getStats" }, (response) => {
        if (chrome.runtime.lastError || !response) {
          statsEl.textContent = "Not running on this page";
          return;
        }
        statsEl.textContent =
          `${response.highlights} highlights | ${response.categories} categories | ` +
          `${response.enabled ? "ON" : "OFF"}`;
      });
    });
  }

  // ---------------------------------------------------------------------------
  // Buttons
  // ---------------------------------------------------------------------------
  btnRefresh.addEventListener("click", () => {
    refreshActiveTab();
    btnRefresh.textContent = "Done!";
    setTimeout(() => { btnRefresh.textContent = "Refresh"; }, 800);
  });

  btnOptions.addEventListener("click", () => {
    chrome.runtime.openOptionsPage();
  });

  // ---------------------------------------------------------------------------
  // Init
  // ---------------------------------------------------------------------------
  loadState();

})();
